package com.revenat.ishop.infrastructure.framework.factory;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import com.revenat.ishop.infrastructure.framework.annotation.persistence.entity.Child;
import com.revenat.ishop.infrastructure.framework.annotation.persistence.entity.Table;
import com.revenat.ishop.infrastructure.framework.annotation.persistence.repository.Insert;
import com.revenat.ishop.infrastructure.framework.exception.FrameworkSystemException;
import com.revenat.ishop.infrastructure.framework.handler.ResultSetHandler;
import com.revenat.ishop.infrastructure.framework.sql.queries.BatchInsertQuery;
import com.revenat.ishop.infrastructure.framework.sql.queries.InsertQuery;
import com.revenat.ishop.infrastructure.framework.util.ReflectionUtils;

/**
 * This component responsible for generating implementation for repository
 * methods annotated with {@link Insert} annotation.
 * 
 * @author Vitaly Dragun
 *
 */
class JDBCInsertHelper extends JDBCAbstractSQLHelper {
	public Object insert(Insert insert, Method method, Object[] args)
			throws IllegalAccessException, InvocationTargetException {
		validateMethodArgs(method, args);

		Object entity = getEntityObject(insert, args);
		Class<?> entityClass = entity.getClass();
		Table table = entityClass.getAnnotation(Table.class);
		validateTableAnnotation(table, entityClass);

		if (insert.batchInsert()) {
			insertEntities((Collection<?>) args[0], table);
			return null;
		} else {
			return insertEntity(entity, table, method, insert.resultSetHandlerClass());
		}
	}

	private void insertEntities(Collection<?> entities, Table table) throws IllegalAccessException {
		Object entity = entities.iterator().next();
		List<Field> entityFields = ReflectionUtils.getAccessibleFields(entity.getClass());

		BatchInsertQuery sql = build(entities, table, entityFields);
		LOGGER.debug("INSERT: {}, {}", sql.getQuery(), sql.getParameters());

		JDBCUtils.insertBatch(JDBCConnectionFactory.getCurrentConnection(), sql.getQuery(), sql.getParameters());

		validateEntityIdFieldPresence(entity, sql.getIdField(), table.id());
	}

	private BatchInsertQuery build(Collection<?> entities, Table table, List<Field> entityFields)
			throws IllegalAccessException {
		StringBuilder sql = new StringBuilder("INSERT INTO ").append(table.name()).append("(");
		StringBuilder values = new StringBuilder(" VALUES (");

		boolean isAutoGeneratedId = table.nextIdExpression().isEmpty();
		String idFieldName = table.id();
		Field idField = findIdField(entityFields, idFieldName);

		String columnList = generateColumnList(entityFields, idFieldName, isAutoGeneratedId);
		String valueList = generateValueList(entityFields, idFieldName, table.nextIdExpression(), isAutoGeneratedId);
		List<Object[]> paramList = new ArrayList<>();
		for (Object entity : entities) {
			Object[] params = generateParameters(entity, entityFields, idFieldName);
			paramList.add(params);
		}

		sql.append(columnList).append(')').append(values).append(valueList).append(')');

		return new BatchInsertQuery(idField, sql.toString(), paramList);
	}

	@SuppressWarnings("rawtypes")
	private Object insertEntity(Object entity, Table table, Method method,
			Class<? extends ResultSetHandler> resultSetHandlerClass)
			throws IllegalAccessException, InvocationTargetException {
		List<Field> entityFields = ReflectionUtils.getAccessibleFields(entity.getClass());

		InsertQuery sql = build(entity, table, entityFields);
		LOGGER.debug("INSERT: {}, {}", sql.getQuery(), sql.getParameters());
		ResultSetHandler<?> resultSetHandler = createResultSetHandler(resultSetHandlerClass, method, entity.getClass());

		Object insertedEntity = JDBCUtils.insert(JDBCConnectionFactory.getCurrentConnection(), sql.getQuery(),
				resultSetHandler, sql.getParameters());
		updateIdField(entity, insertedEntity, sql.getIdField(), table.id());
		return entity;
	}

	private InsertQuery build(Object entity, Table table, List<Field> entityFields) throws IllegalAccessException {
		StringBuilder sql = new StringBuilder("INSERT INTO ").append(table.name()).append("(");
		StringBuilder values = new StringBuilder(" VALUES (");

		boolean isAutoGeneratedId = table.nextIdExpression().isEmpty();
		String idFieldName = table.id();
		Field idField = findIdField(entityFields, idFieldName);

		String columnList = generateColumnList(entityFields, idFieldName, isAutoGeneratedId);
		String valueList = generateValueList(entityFields, idFieldName, table.nextIdExpression(), isAutoGeneratedId);
		Object[] params = generateParameters(entity, entityFields, idFieldName);

		sql.append(columnList).append(')').append(values).append(valueList).append(')');

		return new InsertQuery(idField, sql.toString(), params);
	}

	private void updateIdField(Object entity, Object insertedEntity, Field idField, String idFieldName)
			throws IllegalAccessException {
		validateEntityIdFieldPresence(entity, idField, idFieldName);

		Object idValue = idField.get(insertedEntity);
		idField.set(entity, idValue);
	}

	private Field findIdField(List<Field> entityFields, String idFieldName) {
		for (Field field : entityFields) {
			if (field.getName().equals(idFieldName)) {
				return field;
			}
		}
		return null;
	}

	private String generateColumnList(List<Field> entityFields, String idFieldName, boolean isAutoGeneratedId) {
		StringBuilder columnList = new StringBuilder();

		for (Field field : entityFields) {
			if (!isAutoGeneratedIdColumn(idFieldName, isAutoGeneratedId, field)) {
				columnList.append(getColumnName(field)).append(',');
			}
		}

		return columnList.deleteCharAt(columnList.length() - 1).toString();
	}

	private String generateValueList(List<Field> entityFields, String idFieldName, String nextIdExpression,
			boolean isAutoGeneratedId) {
		StringBuilder valueList = new StringBuilder();

		for (Field field : entityFields) {
			if (field.getName().equals(idFieldName) && !isAutoGeneratedId) {
				valueList.append(nextIdExpression).append(',');
			} else if (!field.getName().equals(idFieldName)) {
				valueList.append("?,");
			}
		}

		return valueList.deleteCharAt(valueList.length() - 1).toString();
	}

	private Object[] generateParameters(Object entity, List<Field> entityFields, String idFieldName)
			throws IllegalAccessException {
		List<Object> params = new ArrayList<>();

		for (Field field : entityFields) {
			if (!field.getName().equals(idFieldName)) {
				params.add(getFieldValue(field, entity));
			}
		}

		return params.toArray();
	}

	private static boolean isAutoGeneratedIdColumn(String idColumnName, boolean isAutoGeneratedId, Field field) {
		return field.getName().equals(idColumnName) && isAutoGeneratedId;
	}

	private String getColumnName(Field field) {
		Child child = field.getAnnotation(Child.class);
		if (child != null) {
			return child.idColumnName().toUpperCase();
		} else {
			return ReflectionUtils.getColumnNameForField(field);
		}
	}

	private Object getFieldValue(Field field, Object entity) throws IllegalAccessException {
		Child child = field.getAnnotation(Child.class);
		Object fieldValue = field.get(entity);
		if (child != null) {
			List<Field> childFields = ReflectionUtils.getAccessibleFields(fieldValue.getClass());
			Field idField = ReflectionUtils.findField(fieldValue.getClass(), childFields, child.idFieldName());
			return idField.get(fieldValue);
		}
		return fieldValue;
	}

	private Object getEntityObject(Insert insert, Object[] args) {
		if (insert.batchInsert()) {
			Collection<?> entities = (Collection<?>) args[0];
			validateEntities(entities);
			return entities.iterator().next();
		}
		return args[0];
	}

	private static void validateEntities(Collection<?> entities) {
		if (entities.isEmpty()) {
			throw new FrameworkSystemException("Entity collection to insert can not be empty");
		}

	}

	private static void validateMethodArgs(Method method, Object[] args) {
		if (args.length != 1) {
			throw new FrameworkSystemException(
					"Method with @Insert annotation: " + method + " should have one argument only!");
		}
	}

	private static void validateTableAnnotation(Table table, Class<?> entityClass) {
		if (table == null) {
			throw new FrameworkSystemException("Entity class " + entityClass + " does not have @Table annotation!");
		}
	}

	private static void validateEntityIdFieldPresence(Object entity, Field idField, String idFieldName) {
		if (idField == null) {
			throw new FrameworkSystemException(
					"Id field with name=" + idFieldName + " not found for class: " + entity.getClass());
		}
	}
}
